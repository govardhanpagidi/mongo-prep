Capped collections are fixed-size collections that support high-throughput operations that insert and retrieve documents based on insertion order.

Capped collections work in a way similar to circular buffers: once a collection fills its allocated space, it makes room for new documents by overwriting the oldest documents in the collection.

As an alternative to capped collections, consider MongoDB's TTL (Time To Live) indexes. As described in Expire Data from Collections by Setting TTL, these indexes allow you to expire and remove data from normal collections based on the value of a date-typed field and a TTL value for the index.

TTL indexes are not compatible with capped collections.

Capped collections guarantee preservation of the insertion order. As a result, queries do not need an index to return documents in insertion order. Without this indexing overhead, capped collections can support higher insertion throughput.

Potential Use Cases - 
	- Store log information generated by high-volume systems. Inserting documents in a capped collection without an index is close to the speed of writing log information directly to a file system. Furthermore, the built-in first-in-first-out property maintains the order of events, while managing storage use.
	- Cache small amounts of data in a capped collections. Since caches are read rather than write heavy, you would either need to ensure that this collection always remains in the working set (i.e. in RAM) or accept some write penalty for the required index or indexes.

Example of capped collection - oplog.rs collection in a replica set

Restrictions and Recommendations
-------------------------------
1. If you plan to update documents in a capped collection, create an index so that these update operations do not require a collection scan.
2. If an update or a replacement operation changes the document size, the operation will fail.
3. You cannot delete documents from a capped collection. To remove all documents from a collection, use the drop() method to drop the collection and recreate the capped collection.
4. You cannot shard a capped collection.
5. Use natural ordering to retrieve the most recently inserted elements from the collection efficiently. This is similar to using the tail command on a log file. To retrieve documents in reverse insertion order, use sort() along with find() with $natural paramater set to -1.
6. The aggregation pipeline stage $out cannot write results to a capped collection.
7. Starting in MongoDB 4.2, you cannot write to capped collections in transactions. Reads from capped collections are still supported in transactions.

db.createCollection( "log", { capped: true, size: 100000 } )
db.createCollection("log", { capped : true, size : 5242880, max : 5000 } )

If the size field is less than or equal to 4096, then the collection will have a cap of 4096 bytes. Otherwise, MongoDB will raise the provided size to make it an integer multiple of 256.

db.runCommand({"convertToCapped": "mycoll", size: 100000});
db.collection.isCapped()


